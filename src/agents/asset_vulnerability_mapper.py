import sys
import os
import json
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from functools import lru_cache
import re

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from agents.base_agent import BaseAgent

class AssetVulnerabilityMapper(BaseAgent):
    def __init__(self):
        super().__init__("asset_vulnerability_mapper", "cybersecurity asset vulnerability analysis and MITRE ATT&CK technique mapping")
        self.max_mitre = int(os.getenv("MAX_MITRE_TECHNIQUES", "8")) 
        
        # OPTIMIZATION: Caches for performance
        self._mitre_technique_cache = {}
        self._system_analysis_cache = {}
        self._search_cache = {}
        
        # DYNAMIC: No hardcoded lists - everything derived from MITRE DB and user input
        # Compatible output format for downstream agents
        
    def get_system_prompt(self):
        return """Expert Asset-Vulnerability Mapper for threat intelligence.

Expertise: MITRE ATT&CK mapping, risk scoring, attack surface analysis, lateral movement assessment.

Focus: Realistic attack scenarios, specific MITRE techniques, actionable threat intelligence.

Return JSON with: findings, mitre_techniques (array of IDs), risk_level, quantitative_analysis, validated_mitre_techniques.
Ensure compatibility with ThreatValidator and ScenarioGenerator downstream processing."""

    def analyze(self, assets_data):
        """FULLY DYNAMIC: Analyze ANY assets and map to ALL relevant MITRE techniques"""
        print("üîç Asset-Vulnerability Mapper: Analyzing systems...")
        
        if not assets_data or 'system_details' not in assets_data:
            return self._generate_no_data_response()
        
        systems = assets_data['system_details']
        print(f"  Processing {len(systems)} systems with dynamic MITRE mapping...")
        
        # DYNAMIC: Extract ALL unique characteristics from systems
        system_characteristics = self._extract_system_characteristics_dynamic(systems)

        system_characteristics_tuple = tuple(system_characteristics.items())
        
        # OPTIMIZATION: Parallel processing for speed
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {
                'inventory': executor.submit(self._prepare_inventory_dynamic, systems),
                'criticality': executor.submit(self._analyze_criticality_dynamic, systems),
                'techniques': executor.submit(self._discover_mitre_techniques_dynamic, system_characteristics_tuple),
                'dependencies': executor.submit(self._analyze_dependencies_dynamic, systems)
            }
            
            # Collect results
            analysis_context = {
                "total_systems": len(systems),
                "system_inventory": futures['inventory'].result(),
                "criticality_analysis": futures['criticality'].result(),
                "relevant_mitre_techniques": futures['techniques'].result(),
                "system_characteristics": system_characteristics,
                "interdependency_mapping": futures['dependencies'].result()
            }
        
        print(f"    Discovered {len(analysis_context['relevant_mitre_techniques'])} relevant MITRE techniques")
        
        # OPTIMIZATION: Skip LLM for small/simple datasets
        if len(systems) <= 3 and len(analysis_context['relevant_mitre_techniques']) <= 5:
            print("  Using fast analysis for simple system set...")
            llm_results = {
                "findings": f"Dynamic analysis of {len(systems)} systems identified {len(analysis_context['relevant_mitre_techniques'])} applicable attack techniques",
                "mitre_techniques": [t['id'] for t in analysis_context['relevant_mitre_techniques']],
                "risk_level": self._calculate_risk_level_fast(analysis_context)
            }
        else:
            # Streamlined LLM prompt for complex scenarios
            prompt = f"""
            Dynamic Asset Analysis:
            - Systems: {len(systems)} with characteristics: {list(system_characteristics.keys())[:10]}
            - Critical Systems: {analysis_context['criticality_analysis']['high_priority_count']}
            - Discovered MITRE Techniques: {len(analysis_context['relevant_mitre_techniques'])}
            - Top Techniques: {[t['id'] + ':' + t['name'][:30] for t in analysis_context['relevant_mitre_techniques'][:8]]}
            
            Provide comprehensive threat analysis mapping systems to attack techniques.
            Return JSON: findings, mitre_techniques (IDs only), risk_level.
            """
            llm_results = self.analyze_with_llm(prompt, analysis_context)
        
        # OPTIMIZATION: Fast enhancement with dynamic metrics
        enhanced_results = self._enhance_with_dynamic_analysis(llm_results, systems, analysis_context)
        
        # COMPATIBILITY: Ensure output format matches downstream expectations
        enhanced_results = self._ensure_compatibility_format(enhanced_results, analysis_context)
        
        # OPTIMIZATION: Batch MITRE validation
        techniques = enhanced_results.get('mitre_techniques', [])
        if isinstance(techniques, dict):
            techniques = list(techniques.values())
        
        validated_techniques = self.validate_mitre_techniques(techniques)
        enhanced_results['validated_mitre_techniques'] = validated_techniques
        
        self.log_analysis(analysis_context, enhanced_results)
        return enhanced_results
    
    def _extract_system_characteristics_dynamic(self, systems):
        """FULLY DYNAMIC: Extract ALL characteristics from ANY system types"""
        characteristics = {}
        
        for system in systems:
            # Extract from all text fields
            text_fields = [
                system.get('system_type', ''),
                system.get('system_name', ''),
                system.get('related_processes', ''),
                system.get('affected_equipment', ''),
                system.get('availability_impact_description', ''),
                system.get('integrity_impact_description', ''),
                system.get('confidentiality_impact_description', '')
            ]
            
            # Dynamic keyword extraction
            all_text = ' '.join(text_fields).lower()
            
            # Extract meaningful keywords (2+ chars, not common words)
            words = re.findall(r'\b[a-zA-Z]{2,}\b', all_text)
            
            # Filter out common words and extract technical terms
            technical_keywords = []
            common_words = {'system', 'the', 'and', 'for', 'with', 'that', 'this', 'are', 'all', 'can', 'has', 'will', 'may', 'data', 'information'}
            
            for word in words:
                if (word not in common_words and 
                    len(word) > 2 and 
                    not word.isdigit()):
                    technical_keywords.append(word)
            
            # Count frequency and importance
            for keyword in technical_keywords:
                characteristics[keyword] = characteristics.get(keyword, 0) + 1
        
        # Return top characteristics by frequency
        sorted_chars = sorted(characteristics.items(), key=lambda x: x[1], reverse=True)
        return dict(sorted_chars[:30])  # Top 30 most relevant characteristics
    
    @lru_cache(maxsize=256)
    def _discover_mitre_techniques_dynamic(self, characteristics_tuple):
        """FULLY DYNAMIC: Discover ALL relevant MITRE techniques from 1000+ database"""
        # Convert tuple back to dict for processing
        characteristics = dict(characteristics_tuple) if isinstance(characteristics_tuple, tuple) else characteristics_tuple
        
        if not characteristics:
            return []
        
        # DYNAMIC: Search MITRE DB for ALL relevant techniques
        all_techniques = []
        search_strategies = []
        
        # Strategy 1: Direct keyword search
        for keyword, frequency in list(characteristics.items())[:15]:  # Top 15 keywords
            if len(keyword) > 3:  # Avoid too generic terms
                search_strategies.append(('keyword', keyword, frequency))
        
        # Strategy 2: Combined term search for technical phrases
        tech_terms = [k for k, v in characteristics.items() if v > 1]  # Terms appearing multiple times
        if len(tech_terms) >= 2:
            for i in range(0, len(tech_terms)-1, 2):
                combined_term = f"{tech_terms[i]} {tech_terms[i+1]}"
                search_strategies.append(('combined', combined_term, 2))
        
        # Strategy 3: Platform-specific searches
        platform_indicators = {
            'windows': ['windows', 'active', 'directory', 'powershell', 'wmi'],
            'linux': ['linux', 'unix', 'bash', 'shell'],
            'web': ['web', 'http', 'application', 'server', 'portal'],
            'database': ['database', 'sql', 'oracle', 'mysql', 'postgres'],
            'network': ['network', 'router', 'switch', 'firewall', 'gateway'],
            'cloud': ['cloud', 'aws', 'azure', 'gcp', 'saas'],
            'mobile': ['mobile', 'android', 'ios', 'device'],
            'email': ['email', 'mail', 'smtp', 'exchange', 'outlook']
        }
        
        for platform, indicators in platform_indicators.items():
            if any(indicator in characteristics for indicator in indicators):
                search_strategies.append(('platform', platform, 3))
        
        print(f"    Using {len(search_strategies)} dynamic search strategies")
        
        # Execute all search strategies
        technique_scores = {}
        
        for strategy_type, search_term, weight in search_strategies:
            try:
                # Search MITRE database
                techniques = self.search_techniques(search_term)
                
                for technique in techniques:
                    tech_id = technique['id']
                    if tech_id not in technique_scores:
                        technique_scores[tech_id] = {
                            'technique': technique,
                            'score': 0,
                            'matches': []
                        }
                    
                    # Weight by strategy type and frequency
                    strategy_score = weight * (2 if strategy_type == 'platform' else 1)
                    technique_scores[tech_id]['score'] += strategy_score
                    technique_scores[tech_id]['matches'].append(f"{strategy_type}:{search_term}")
                    
            except Exception as e:
                print(f"    Search error for '{search_term}': {e}")
                continue
        
        # OPTIMIZATION: Sort by relevance score and return top techniques
        sorted_techniques = sorted(
            technique_scores.values(),
            key=lambda x: x['score'],
            reverse=True
        )
        
        # Return top 20 most relevant techniques
        max_mitre = int(os.getenv("MAX_MITRE_TECHNIQUES", "8"))
        return [item['technique'] for item in sorted_techniques[:max_mitre]]
    
    def _prepare_inventory_dynamic(self, systems):
        """DYNAMIC: Prepare inventory for ANY system types"""
        inventory = []
        
        for system in systems:
            # DYNAMIC: Extract attack surface indicators based on actual content
            indicators = self._identify_attack_indicators_dynamic(system)
            
            # DYNAMIC: Calculate exposure score based on content
            exposure_score = self._calculate_exposure_dynamic(system)
            
            inventory.append({
                "name": system.get('system_name', 'Unknown'),
                "type": system.get('system_type', 'Unknown'),
                "criticality": system.get('system_criticality', 'Unknown'),
                "site": system.get('site', 'Unknown'),
                "attack_surface_indicators": indicators,
                "exposure_score": exposure_score,
                "processes": system.get('related_processes', ''),
                "equipment": system.get('affected_equipment', ''),
                "impact_summary": self._summarize_impact_dynamic(system)
            })
        
        return inventory
    
    def _identify_attack_indicators_dynamic(self, system):
        """FULLY DYNAMIC: Identify attack indicators from ANY system description"""
        indicators = []
        
        # Combine all descriptive text
        all_text = ' '.join([
            system.get('system_type', ''),
            system.get('related_processes', ''),
            system.get('affected_equipment', ''),
            system.get('availability_impact_description', ''),
            system.get('integrity_impact_description', ''),
            system.get('confidentiality_impact_description', '')
        ]).lower()
        
        # DYNAMIC: Attack vector mapping based on content analysis
        attack_patterns = {
            'web_application_attacks': ['web', 'http', 'application', 'portal', 'website', 'server'],
            'database_attacks': ['database', 'sql', 'data', 'oracle', 'mysql', 'postgres'],
            'email_attacks': ['email', 'mail', 'smtp', 'phishing', 'message'],
            'network_attacks': ['network', 'router', 'switch', 'firewall', 'gateway', 'infrastructure'],
            'credential_attacks': ['auth', 'authentication', 'directory', 'identity', 'login', 'password'],
            'remote_access': ['remote', 'vpn', 'rdp', 'ssh', 'terminal'],
            'file_system_attacks': ['file', 'storage', 'share', 'document', 'backup'],
            'privilege_escalation': ['admin', 'root', 'privilege', 'elevated', 'superuser'],
            'lateral_movement': ['domain', 'active directory', 'kerberos', 'ldap'],
            'data_exfiltration': ['sensitive', 'confidential', 'personal', 'financial', 'customer'],
            'external_exposure': ['internet', 'public', 'external', 'dmz', 'exposed'],
            'high_value_target': ['financial', 'payment', 'transaction', 'revenue', 'critical']
        }
        
        # DYNAMIC: Check for pattern matches
        for attack_type, keywords in attack_patterns.items():
            if any(keyword in all_text for keyword in keywords):
                indicators.append(attack_type)
        
        # DYNAMIC: Process-specific indicators
        processes = system.get('related_processes', '').lower()
        if processes:
            if 'external' in processes or 'internet' in processes:
                indicators.append('external_connectivity')
            if 'customer' in processes or 'client' in processes:
                indicators.append('customer_facing')
            if 'financial' in processes or 'payment' in processes:
                indicators.append('financial_processing')
        
        return list(set(indicators))  # Remove duplicates
    
    def _calculate_exposure_dynamic(self, system):
        """DYNAMIC: Calculate exposure score based on system characteristics"""
        score = 0
        
        # Criticality impact (0-40 points)
        criticality = system.get('system_criticality', '').lower()
        criticality_scores = {
            'veryhigh': 40, 'critical': 40, 'very high': 40,
            'high': 30, 'medium': 20, 'low': 10
        }
        score += criticality_scores.get(criticality, 15)  # Default 15 for unknown
        
        # External exposure (0-30 points)
        text_content = ' '.join([
            system.get('system_type', ''),
            system.get('related_processes', ''),
            system.get('affected_equipment', '')
        ]).lower()
        
        exposure_keywords = {
            'internet': 15, 'public': 15, 'external': 15, 'web': 10,
            'dmz': 12, 'exposed': 10, 'remote': 8, 'accessible': 5
        }
        
        for keyword, points in exposure_keywords.items():
            if keyword in text_content:
                score += points
                break  # Only count highest exposure type
        
        # Data sensitivity (0-20 points)
        sensitive_keywords = {
            'customer': 10, 'financial': 15, 'personal': 12, 'confidential': 15,
            'sensitive': 10, 'private': 8, 'protected': 8
        }
        
        for keyword, points in sensitive_keywords.items():
            if keyword in text_content:
                score += points
                break  # Only count highest sensitivity
        
        # Business impact (0-10 points)
        impact_text = ' '.join([
            system.get('availability_impact_description', ''),
            system.get('integrity_impact_description', ''),
            system.get('confidentiality_impact_description', '')
        ]).lower()
        
        if any(keyword in impact_text for keyword in ['critical', 'severe', 'major']):
            score += 10
        elif any(keyword in impact_text for keyword in ['significant', 'moderate']):
            score += 6
        elif any(keyword in impact_text for keyword in ['minor', 'low']):
            score += 3
        
        return min(score, 100)  # Cap at 100
    
    def _summarize_impact_dynamic(self, system):
        """DYNAMIC: Summarize business impact from any system description"""
        impacts = []
        
        # Extract impact descriptions
        availability = system.get('availability_impact_description', '')
        integrity = system.get('integrity_impact_description', '')
        confidentiality = system.get('confidentiality_impact_description', '')
        
        if availability:
            impacts.append(f"Availability: {availability[:100]}...")
        if integrity:
            impacts.append(f"Integrity: {integrity[:100]}...")
        if confidentiality:
            impacts.append(f"Confidentiality: {confidentiality[:100]}...")
        
        return impacts
    
    def _analyze_criticality_dynamic(self, systems):
        """DYNAMIC: Analyze criticality for any classification system"""
        criticality_distribution = {}
        high_priority_systems = []
        
        # DYNAMIC: Handle any criticality naming convention
        high_criticality_indicators = [
            'veryhigh', 'very high', 'critical', 'essential', 'vital',
            'maximum', 'highest', 'severe', 'tier 1', 'level 1'
        ]
        
        for system in systems:
            criticality = system.get('system_criticality', 'Unknown').lower()
            criticality_distribution[criticality] = criticality_distribution.get(criticality, 0) + 1
            
            # DYNAMIC: Check if system is high priority
            if (criticality in high_criticality_indicators or
                any(indicator in criticality for indicator in high_criticality_indicators)):
                high_priority_systems.append({
                    'name': system.get('system_name'),
                    'type': system.get('system_type'),
                    'criticality': criticality,
                    'exposure_score': self._calculate_exposure_dynamic(system)
                })
        
        return {
            "distribution": criticality_distribution,
            "high_priority_count": len(high_priority_systems),
            "high_priority_systems": high_priority_systems,
            "total_systems": len(systems)
        }
    
    def _analyze_dependencies_dynamic(self, systems):
        """DYNAMIC: Analyze interdependencies for lateral movement assessment"""
        dependencies = []
        
        # Group systems by site for lateral movement analysis
        sites = {}
        for system in systems:
            site = system.get('site', 'Unknown')
            if site not in sites:
                sites[site] = []
            sites[site].append(system)
        
        # DYNAMIC: Identify dependency patterns
        for site, site_systems in sites.items():
            if len(site_systems) > 1:
                # Systems in same site can potentially communicate
                for i, sys1 in enumerate(site_systems):
                    for sys2 in site_systems[i+1:]:
                        # DYNAMIC: Determine relationship type
                        relationship = self._determine_relationship_dynamic(sys1, sys2)
                        if relationship:
                            dependencies.append({
                                'source': sys1.get('system_name'),
                                'target': sys2.get('system_name'),
                                'site': site,
                                'relationship': relationship,
                                'lateral_movement_risk': self._calculate_lateral_risk_dynamic(sys1, sys2)
                            })
        
        return dependencies
    
    def _determine_relationship_dynamic(self, sys1, sys2):
        """DYNAMIC: Determine relationship between any two systems"""
        sys1_type = sys1.get('system_type', '').lower()
        sys2_type = sys2.get('system_type', '').lower()
        
        # DYNAMIC: Common relationship patterns
        if 'database' in sys1_type and 'web' in sys2_type:
            return 'data_access'
        elif 'web' in sys1_type and 'database' in sys2_type:
            return 'data_access'
        elif 'auth' in sys1_type or 'directory' in sys1_type:
            return 'authentication'
        elif 'auth' in sys2_type or 'directory' in sys2_type:
            return 'authentication'
        elif 'network' in sys1_type or 'network' in sys2_type:
            return 'network_infrastructure'
        elif 'email' in sys1_type or 'email' in sys2_type:
            return 'communication'
        else:
            return 'shared_infrastructure'
    
    def _calculate_lateral_risk_dynamic(self, sys1, sys2):
        """DYNAMIC: Calculate lateral movement risk between systems"""
        # Base risk factors
        risk_factors = []
        
        # Same site = higher risk
        if sys1.get('site') == sys2.get('site'):
            risk_factors.append('same_site')
        
        # High criticality systems = higher risk
        sys1_crit = sys1.get('system_criticality', '').lower()
        sys2_crit = sys2.get('system_criticality', '').lower()
        
        if any(crit in ['veryhigh', 'critical', 'very high'] for crit in [sys1_crit, sys2_crit]):
            risk_factors.append('high_criticality')
        
        # Authentication systems = very high risk
        if any('auth' in sys.get('system_type', '').lower() for sys in [sys1, sys2]):
            risk_factors.append('authentication_system')
        
        # Determine risk level
        if len(risk_factors) >= 3 or 'authentication_system' in risk_factors:
            return 'Very High'
        elif len(risk_factors) >= 2:
            return 'High'
        elif len(risk_factors) >= 1:
            return 'Medium'
        else:
            return 'Low'
    
    def _enhance_with_dynamic_analysis(self, llm_results, systems, analysis_context):
        """OPTIMIZATION: Enhance with dynamic calculated metrics"""
        enhanced = llm_results.copy() if isinstance(llm_results, dict) else {}
        
        # DYNAMIC: Calculate comprehensive quantitative analysis
        enhanced['quantitative_analysis'] = {
            'total_systems_analyzed': len(systems),
            'critical_systems_count': analysis_context['criticality_analysis']['high_priority_count'],
            'attack_surface_score': self._calculate_attack_surface_dynamic(systems),
            'lateral_movement_paths': len(analysis_context['interdependency_mapping']),
            'privilege_escalation_opportunities': self._count_privilege_opportunities_dynamic(systems),
            'external_exposure_count': self._count_external_exposure_dynamic(systems),
            'data_sensitivity_score': self._calculate_data_sensitivity_dynamic(systems)
        }
        
        # DYNAMIC: Risk prioritization
        enhanced['risk_prioritization'] = self._prioritize_systems_dynamic(systems)
        
        # DYNAMIC: Attack vector summary
        enhanced['primary_attack_vectors'] = self._identify_attack_vectors_dynamic(systems)
        
        return enhanced
    
    def _calculate_attack_surface_dynamic(self, systems):
        """DYNAMIC: Calculate attack surface for any system mix"""
        total_score = 0
        
        for system in systems:
            system_score = self._calculate_exposure_dynamic(system)
            total_score += system_score
        
        # Average and normalize
        return round(total_score / len(systems) if systems else 0, 1)
    
    def _count_privilege_opportunities_dynamic(self, systems):
        """DYNAMIC: Count privilege escalation opportunities"""
        opportunities = 0
        
        privilege_keywords = [
            'auth', 'authentication', 'directory', 'identity', 'admin',
            'domain', 'controller', 'privilege', 'elevated', 'root'
        ]
        
        for system in systems:
            system_text = ' '.join([
                system.get('system_type', ''),
                system.get('system_name', ''),
                system.get('related_processes', '')
            ]).lower()
            
            if any(keyword in system_text for keyword in privilege_keywords):
                opportunities += 1
        
        return opportunities
    
    def _count_external_exposure_dynamic(self, systems):
        """DYNAMIC: Count externally exposed systems"""
        exposed_count = 0
        
        exposure_keywords = ['internet', 'public', 'external', 'dmz', 'web', 'portal']
        
        for system in systems:
            system_text = ' '.join([
                system.get('system_type', ''),
                system.get('related_processes', '')
            ]).lower()
            
            if any(keyword in system_text for keyword in exposure_keywords):
                exposed_count += 1
        
        return exposed_count
    
    def _calculate_data_sensitivity_dynamic(self, systems):
        """DYNAMIC: Calculate data sensitivity score"""
        sensitivity_scores = []
        
        for system in systems:
            system_score = 0
            
            all_text = ' '.join([
                system.get('system_type', ''),
                system.get('related_processes', ''),
                system.get('confidentiality_impact_description', '')
            ]).lower()
            
            # DYNAMIC sensitivity scoring
            if any(keyword in all_text for keyword in ['financial', 'payment', 'transaction']):
                system_score += 30
            if any(keyword in all_text for keyword in ['customer', 'personal', 'pii']):
                system_score += 25
            if any(keyword in all_text for keyword in ['confidential', 'sensitive', 'protected']):
                system_score += 20
            if any(keyword in all_text for keyword in ['proprietary', 'trade secret', 'intellectual']):
                system_score += 15
            
            sensitivity_scores.append(min(system_score, 100))
        
        return round(sum(sensitivity_scores) / len(sensitivity_scores) if sensitivity_scores else 0, 1)
    
    def _prioritize_systems_dynamic(self, systems):
        """DYNAMIC: Prioritize systems by comprehensive risk assessment"""
        system_risks = []
        
        for system in systems:
            # DYNAMIC: Multi-factor risk calculation
            exposure_score = self._calculate_exposure_dynamic(system)
            
            # Additional risk factors
            risk_factors = []
            
            # Criticality factor
            criticality = system.get('system_criticality', '').lower()
            if criticality in ['veryhigh', 'critical', 'very high']:
                risk_factors.append('Critical System')
            
            # External exposure factor
            if self._count_external_exposure_dynamic([system]) > 0:
                risk_factors.append('External Exposure')
            
            # Data sensitivity factor
            if self._calculate_data_sensitivity_dynamic([system]) > 50:
                risk_factors.append('Sensitive Data')
            
            # Privilege system factor
            if self._count_privilege_opportunities_dynamic([system]) > 0:
                risk_factors.append('Privilege Control')
            
            # Business impact factor
            impact_text = ' '.join([
                system.get('availability_impact_description', ''),
                system.get('integrity_impact_description', ''),
                system.get('confidentiality_impact_description', '')
            ]).lower()
            
            if any(keyword in impact_text for keyword in ['critical', 'severe', 'major', 'significant']):
                risk_factors.append('High Business Impact')
            
            # Determine priority
            if exposure_score >= 80:
                priority = 'Critical'
            elif exposure_score >= 60:
                priority = 'High'
            elif exposure_score >= 40:
                priority = 'Medium'
            else:
                priority = 'Low'
            
            system_risks.append({
                'system_name': system.get('system_name'),
                'risk_score': exposure_score,
                'risk_factors': risk_factors,
                'priority': priority,
                'system_type': system.get('system_type')
            })
        
        # Sort by risk score
        system_risks.sort(key=lambda x: x['risk_score'], reverse=True)
        return system_risks[:15]  # Top 15 riskiest systems
    
    def _identify_attack_vectors_dynamic(self, systems):
        """DYNAMIC: Identify attack vectors from actual system inventory"""
        vectors = {}
        
        for system in systems:
            # Get attack indicators for this system
            indicators = self._identify_attack_indicators_dynamic(system)
            
            # Map indicators to attack vectors
            for indicator in indicators:
                vector_name = indicator.replace('_', ' ').title()
                vectors[vector_name] = vectors.get(vector_name, 0) + 1
        
        return vectors
    
    def _calculate_risk_level_fast(self, analysis_context):
        """OPTIMIZATION: Fast risk level calculation"""
        critical_count = analysis_context['criticality_analysis']['high_priority_count']
        total_systems = analysis_context['total_systems']
        technique_count = len(analysis_context['relevant_mitre_techniques'])
        
        if total_systems == 0:
            return "Low"
        # Simple risk calculation
        risk_score = (critical_count / total_systems * 50) + (min(technique_count, 10) * 5)
        
        if risk_score >= 70:
            return 'Critical'
        elif risk_score >= 50:
            return 'High'
        elif risk_score >= 30:
            return 'Medium'
        else:
            return 'Low'
    
    def _ensure_compatibility_format(self, enhanced_results, analysis_context):
        """COMPATIBILITY: Ensure output format matches downstream agent expectations"""
        # ThreatValidator expects: mitre_techniques, validated_mitre_techniques, quantitative_analysis
        # ScenarioGenerator expects: mitre_techniques, validated_mitre_techniques, quantitative_analysis
        # QualityGate expects: validated components with proper structure
        
        # Ensure mitre_techniques is always a list of IDs
        if 'mitre_techniques' not in enhanced_results:
            enhanced_results['mitre_techniques'] = [t['id'] for t in analysis_context['relevant_mitre_techniques']]
        
        # Ensure we have the required quantitative_analysis structure
        if 'quantitative_analysis' not in enhanced_results:
            enhanced_results['quantitative_analysis'] = {
                'total_systems_analyzed': analysis_context['total_systems'],
                'critical_systems_count': analysis_context['criticality_analysis']['high_priority_count'],
                'attack_surface_score': 50  # Default
            }
        
        # Ensure we have findings
        if 'findings' not in enhanced_results:
            enhanced_results['findings'] = f"Dynamic analysis of {analysis_context['total_systems']} systems"
        
        # Ensure we have risk_level
        if 'risk_level' not in enhanced_results:
            enhanced_results['risk_level'] = self._calculate_risk_level_fast(analysis_context)
        
        return enhanced_results
    
    def _generate_no_data_response(self):
        """COMPATIBILITY: Generate response when no asset data is provided"""
        return {
            "findings": "No asset inventory data provided for analysis",
            "mitre_techniques": [],
            "validated_mitre_techniques": [],
            "risk_level": "Unknown",
            "quantitative_analysis": {
                "total_systems_analyzed": 0,
                "critical_systems_count": 0,
                "attack_surface_score": 0
            },
            "recommendations": ["Provide comprehensive asset inventory for threat analysis"],
            "confidence": 1,
            "status": "insufficient_data"
        }

def test_asset_mapper_dynamics():
    """Test if AssetVulnerabilityMapper returns dynamic results based on input"""
    
    try:
        from agents.asset_vulnerability_mapper import AssetVulnerabilityMapper
    except ImportError as e:
        print(f"Error importing AssetVulnerabilityMapper: {e}")
        return False
    
    mapper = AssetVulnerabilityMapper()
    
    print("Testing Asset Vulnerability Mapper Dynamic Behavior...")
    print("=" * 60)
    
    # Test Case 1: Single simple database system
    print("\nüß™ TEST 1: Single Database System")
    single_db_assets = {
        "system_details": [
            {
                "system_name": "Customer Database",
                "system_type": "Database System",
                "system_criticality": "High"
            }
        ]
    }
    
    result1 = mapper.analyze(single_db_assets)
    techniques1 = len(result1.get('mitre_techniques', []))
    risk1 = result1.get('risk_level', 'Unknown')
    print(f"  MITRE Techniques: {techniques1}")
    print(f"  Risk Level: {risk1}")
    
    # Test Case 2: Multiple complex modern systems
    print("\nüß™ TEST 2: Multiple Complex Modern Systems")
    complex_assets = {
        "system_details": [
            {
                "system_name": "Kubernetes Cluster",
                "system_type": "Container Orchestration Platform", 
                "system_criticality": "VeryHigh",
                "site": "Cloud Infrastructure",
                "related_processes": "Microservices, API Gateway, Service Mesh",
                "affected_equipment": "K8s clusters, ingress controllers"
            },
            {
                "system_name": "IoT Management Platform",
                "system_type": "Industrial IoT Control System",
                "system_criticality": "Critical", 
                "site": "Manufacturing Plant",
                "related_processes": "Industrial automation, SCADA integration",
                "affected_equipment": "PLCs, sensors, actuators"
            },
            {
                "system_name": "AI Training Pipeline",
                "system_type": "Machine Learning Infrastructure",
                "system_criticality": "High",
                "site": "GPU Farm",
                "related_processes": "Model training, data processing",
                "affected_equipment": "GPU clusters, ML platforms"
            },
            {
                "system_name": "Blockchain Gateway",
                "system_type": "Cryptocurrency Platform",
                "system_criticality": "VeryHigh",
                "site": "Secure Datacenter", 
                "related_processes": "Crypto transactions, wallet management",
                "affected_equipment": "Blockchain nodes, wallet servers"
            }
        ]
    }
    
    result2 = mapper.analyze(complex_assets)
    techniques2 = len(result2.get('mitre_techniques', []))
    risk2 = result2.get('risk_level', 'Unknown')
    print(f"  MITRE Techniques: {techniques2}")
    print(f"  Risk Level: {risk2}")
    
    # Test Case 3: Traditional web systems
    print("\nüß™ TEST 3: Traditional Web Systems")
    web_assets = {
        "system_details": [
            {
                "system_name": "Company Website",
                "system_type": "Web Application Server",
                "system_criticality": "Medium"
            },
            {
                "system_name": "Internal Portal",
                "system_type": "Intranet Application", 
                "system_criticality": "Medium"
            }
        ]
    }
    
    result3 = mapper.analyze(web_assets)
    techniques3 = len(result3.get('mitre_techniques', []))
    risk3 = result3.get('risk_level', 'Unknown')
    print(f"  MITRE Techniques: {techniques3}")
    print(f"  Risk Level: {risk3}")
    
    # Test Case 4: Empty systems (edge case)
    print("\nüß™ TEST 4: Empty Systems")
    empty_assets = {
        "system_details": []
    }
    
    result4 = mapper.analyze(empty_assets)
    techniques4 = len(result4.get('mitre_techniques', []))
    risk4 = result4.get('risk_level', 'Unknown')
    print(f"  MITRE Techniques: {techniques4}")
    print(f"  Risk Level: {risk4}")
    
    # Analysis
    results = [techniques1, techniques2, techniques3, techniques4]
    unique_counts = set(results)
    is_dynamic = len(unique_counts) > 1
    
    print(f"\nüìä RESULTS SUMMARY:")
    print(f"Single Database: {techniques1} techniques, Risk: {risk1}")
    print(f"Complex Modern: {techniques2} techniques, Risk: {risk2}")
    print(f"Traditional Web: {techniques3} techniques, Risk: {risk3}")
    print(f"Empty Systems: {techniques4} techniques, Risk: {risk4}")
    
    print(f"\nüéØ ANALYSIS:")
    print(f"Technique counts: {results}")
    print(f"Unique counts: {sorted(unique_counts)}")
    print(f"Dynamic Behavior: {'‚úÖ YES - Results vary by system type/complexity' if is_dynamic else '‚ùå NO - Hardcoded pattern detected'}")
    
    # Additional checks
    if techniques2 > techniques1 > techniques4:
        print(f" Logical scaling - Complex systems have more techniques than simple")
    else:
        print(f"Unexpected scaling - Complex: {techniques2}, Simple: {techniques1}, Empty: {techniques4}")
    
    # Check for unrealistic values
    if any(t > 100 for t in results):
        print(f" Unrealistic technique counts detected (>100)")
    
    if techniques4 == 0:
        print(f" Empty systems correctly return 0 techniques")
    else:
        print(f" Empty systems should return 0 techniques, got {techniques4}")
    
    # Risk level analysis
    risks = [risk1, risk2, risk3, risk4]
    unique_risks = set(risks)
    risk_dynamic = len(unique_risks) > 1
    
    print(f"Risk Level Variation: {' YES' if risk_dynamic else ' NO'} - {sorted(unique_risks)}")
    
    return is_dynamic and risk_dynamic

if __name__ == "__main__":
    is_dynamic = test_asset_mapper_dynamics()
    
    if is_dynamic:
        print(f"\n === Asset Vulnerability Mapper is DYNAMIC - Ready for next test")
    else:
        print(f"\n ==== Asset Vulnerability Mapper may need fixes - Check for hardcoded behavior")